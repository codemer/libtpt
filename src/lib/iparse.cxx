/*
 * iparse.cxx
 *
 * IParser - Interactive Parser
 *
 * Copyright (C) 2002-2009 Isaac W. Foraker (isaac at noscience dot net)
 * All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of the Author nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include "conf.h"
#include "parse_impl.h"
#include <libtpt/iparse.h>
#include <algorithm>
#include <sstream>
#include <iostream>

namespace TPT {


/**
 * Construct a IParser for the specified file and Symbols table.
 *
 * @param   filename    Path to TPT source file.
 * @param   st          Reference to Symbols table.
 */
IParser::IParser(const char* filename, Symbols& st)
{
    imp = new Parser_Impl(filename, st);
}

/**
 * Construct a IParser for the specified fixed length buffer and Symbols
 * table.
 *
 * @param   buffer      Pointer to buffer of TPT source.
 * @param   size        Size of TPT source buffer.
 * @param   st          Symbols table for read and write.
 */
IParser::IParser(const char* buffer, unsigned long size, Symbols& st)
{
    imp = new Parser_Impl(buffer, size, st);
}

/**
 * Construct a IParser for a Buffer and Symbols table.
 *
 * @param   buf         Reference to Buffer containing source template.
 * @param   st          Reference to Symbols table.
 */
IParser::IParser(Buffer& buf, Symbols& st)
{
    imp = new Parser_Impl(buf, st);
}

/**
 * Destruct this IParser.
 *
 */
IParser::~IParser()
{
    delete imp;
}

/**
 * Parse the template in Buffer and return the result as a string.
 *
 * Note: This method is provided for completeness, but the preferred
 * method of parsing is to use streams instead.
 */
std::string IParser::run()
{
    std::string temp;
    std::stringstream ss(temp);
    run(ss);
    return ss.str();
}

/**
 * Parse the template in Buffer, outputing the result to the given
 * stream while parsing.
 *
 * @param   os      Reference to an output stream to write.
 * @return  false on success;
 * @return  true if there were errors or warnings.
 */
bool IParser::run(std::ostream& os)
{
    imp->errlist.clear();
    return imp->pass1(&os);
}

/**
 * Perform only syntax checking on Buffer.
 *
 * @return  false on success;
 * @return  true if there were errors or warnings.
 */
bool IParser::syntax()
{
    return imp->pass1(0);
}

/**
 * Get the number of errors and warnings.
 *
 * @return  0 is good.
 */
unsigned IParser::geterrorcount() const
{
    return imp->errlist.size();
}

/**
 * Copy the errors and warnings generated by the last parse into
 * the specified array.
 *
 * @param   errlist     Reference to array to receive list.
 * @return  false if no errors;
 * @return  true if errors copied.
 */
bool IParser::geterrorlist(ErrorList& errlist)
{
    if (!imp->errlist.empty())
    {
        errlist = imp->errlist;
        return true;
    }
    else
    {
        errlist.clear();
        return false;
    }
}


/**
 * Add a path to the Include search list.  By default, only ./ is
 * searched.
 *
 * @param   path    Path to be searched for include files.
 * @return  nothing
 */
void IParser::addincludepath(const char* path)
{
    imp->inclist.push_back(path);
}


/**
 * Register a callback function to handle TPT calls to the specified
 * function name.
 *
 * See the LibTPT Documentation for details on how to write a
 * a callback funcion.
 *
 * @param   name    Name of the function (without the @).
 * @param   func    Function to use as callback.
 * @return  false on success;
 * @return  true if name already is registered to another function.
 */
bool IParser::addfunction(const char* name,
        bool (*func)(std::ostream&, Object&))
{
    if (imp->isuserfunc(name))
        return true;
    imp->funcs[name] = func;
    return false;
}

} // end namespace TPT
